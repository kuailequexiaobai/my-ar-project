<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AR Particle Morph</title>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<style>
body {
  margin: 0;
  overflow: hidden;
  background: #000;
}
#startBtn{
  position:fixed;
  top:0; left:0; right:0; bottom:0;
  margin:auto;
  width:200px; height:60px;
  background:#00baff; color:#fff;
  border:none; border-radius:14px;
  font-size:20px;
}
#videoElement{
  position:fixed;
  left:0; top:0;
  width:1px; height:1px;
  opacity:0;
}
</style>
</head>

<body>

<button id="startBtn">启动 AR</button>
<video id="videoElement" autoplay playsinline></video>

<script>
/* ----------------------------------------------------------
   基础 Three.js 场景
---------------------------------------------------------- */
let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(0,0,400);

let renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ----------------------------------------------------------
   粒子系统
---------------------------------------------------------- */
const COUNT = 16000;
let geometry = new THREE.BufferGeometry();
let positions = new Float32Array(COUNT * 3);
let velocities = new Float32Array(COUNT * 3);
let targets = new Float32Array(COUNT * 3);

function rand(){
  return (Math.random()*2 - 1);
}

// 初始随机位置
for(let i=0;i<COUNT;i++){
  positions[i*3]   = rand()*400;
  positions[i*3+1] = rand()*400;
  positions[i*3+2] = rand()*400;
}
geometry.setAttribute("position", new THREE.BufferAttribute(positions,3));

let material = new THREE.PointsMaterial({
  color:0x55ccff,
  size:4,
  transparent:true,
  opacity:0.9
});

let points = new THREE.Points(geometry, material);
scene.add(points);

/* ----------------------------------------------------------
   形状生成器（关键）
   -> 每种手势都有自己的目标点云
---------------------------------------------------------- */
function makeSphere(){
  for(let i=0;i<COUNT;i++){
    let r = 120;
    let u = Math.random();
    let v = Math.random();
    let theta = 2 * Math.PI * u;
    let phi = Math.acos(2*v - 1);
    let x = r * Math.sin(phi)*Math.cos(theta);
    let y = r * Math.sin(phi)*Math.sin(theta);
    let z = r * Math.cos(phi);

    targets[i*3] = x;
    targets[i*3+1] = y;
    targets[i*3+2] = z;
  }
}

function makeTorus(){
  for(let i=0;i<COUNT;i++){
    let R = 150, r=40;
    let u = Math.random()*Math.PI*2;
    let v = Math.random()*Math.PI*2;
    let x = (R + r*Math.cos(v))* Math.cos(u);
    let y = (R + r*Math.cos(v))* Math.sin(u);
    let z = r * Math.sin(v);

    targets[i*3] = x;
    targets[i*3+1] = y;
    targets[i*3+2] = z;
  }
}

function makeStar(){
  for(let i=0;i<COUNT;i++){
    let r1 = 60, r2=150;
    let a = Math.random()*Math.PI*2;
    let r = (Math.floor(Math.random()*5)%2===0)? r2:r1;
    let x = r * Math.cos(a);
    let y = r * Math.sin(a);
    let z = (Math.random()*20)-10;

    targets[i*3] = x;
    targets[i*3+1] = y;
    targets[i*3+2] = z;
  }
}

function makeHeart(){
  for(let i=0;i<COUNT;i++){
    let t = Math.random()*Math.PI*2;
    let x = 16*Math.pow(Math.sin(t),3);
    let y = 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
    x*=10; y*=10;
    let z = (Math.random()*30)-15;

    targets[i*3] = x;
    targets[i*3+1] = y;
    targets[i*3+2] = z;
  }
}

function makeMokText(){
  for(let i=0;i<COUNT;i++){
    let x = (Math.random()*300)-150;
    let y = (Math.random()*120)-60;
    let z = (Math.random()*20)-10;

    targets[i*3] = x;
    targets[i*3+1] = y;
    targets[i*3+2] = z;
  }
}

/* ----------------------------------------------------------
   手势 → 形状映射
---------------------------------------------------------- */
let currentShape = "sphere";

function switchShape(type){
  currentShape = type;
  if(type==="sphere") makeSphere();
  if(type==="ring") makeTorus();
  if(type==="star") makeStar();
  if(type==="heart") makeHeart();
  if(type==="mok") makeMokText();
}

/* ---------- 第二部分开始（直接追加到第一部分后） ---------- */

/////////////////////// 手势与 MediaPipe 初始化 ///////////////////////
const videoEl = document.getElementById('videoElement');
const startButton = document.getElementById('startBtn');

let mpHands = null;
let mpCamera = null;

// 上一帧手心中心与时间（用于手速计算）
let prevHandCenter = null;
let prevHandTime = null;
let handWind = 0; // 当前测得的“风力”（由手速驱动）
let handDepthScale = 1.0; // 由手覆盖面积控制整体缩放

// 简单且可靠的手势判定（使用 landmarks 索引）
function fingerExtended(landmarks, tip, pip){
  // tip.y < pip.y 表示指尖在上（伸直）。使用微小阈值避免抖动
  return landmarks[tip].y < landmarks[pip].y - 0.02;
}
function thumbOut(landmarks){
  return Math.abs(landmarks[4].x - landmarks[0].x) > 0.08;
}
function detectGesture(landmarks){
  if(!landmarks || landmarks.length === 0) return 'none';
  const tips = [4,8,12,16,20];
  const pips = [3,7,11,15,19];
  const idx = fingerExtended(landmarks, tips[1], pips[1]);
  const mid = fingerExtended(landmarks, tips[2], pips[2]);
  const ring = fingerExtended(landmarks, tips[3], pips[3]);
  const pink = fingerExtended(landmarks, tips[4], pips[4]);
  const thumb = thumbOut(landmarks);
  const extCount = [idx,mid,ring,pink].filter(x=>x).length;

  if(extCount === 4 && thumb) return 'open_palm';
  if(!thumb && extCount === 0) return 'fist';
  if(thumb && extCount === 0) return 'thumbs_up';
  if(idx && mid && !thumb && !ring && !pink) return 'scissor_hand';
  if(idx && !mid && !thumb) return 'index_finger';
  return 'static';
}

// 计算手掌中心与包围框（用于深度）
function handMetrics(landmarks){
  let minX=1,minY=1,maxX=0,maxY=0, cx=0, cy=0;
  for(let i=0;i<landmarks.length;i++){
    const p = landmarks[i];
    cx += p.x; cy += p.y;
    minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
    maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
  }
  cx /= landmarks.length; cy /= landmarks.length;
  return { center:{x:cx, y:cy}, boxW: maxX-minX, boxH: maxY-minY, area: (maxX-minX)*(maxY-minY) };
}

// MediaPipe 回调
function onResults(results){
  if(!results.multiHandLandmarks || results.multiHandLandmarks.length === 0){
    // 无手：逐渐回落风力与深度
    handWind = Math.max(0, handWind * 0.94);
    handDepthScale = THREE.MathUtils.lerp(handDepthScale, 1.0, 0.06);
    return;
  }

  const landmarks = results.multiHandLandmarks[0];
  const metrics = handMetrics(landmarks);
  const now = performance.now();

  // 计算手速 -> 风力（px/s -> small scalar）
  if(prevHandCenter && prevHandTime){
    const dx = (metrics.center.x - prevHandCenter.x) * window.innerWidth;
    const dy = (metrics.center.y - prevHandCenter.y) * window.innerHeight;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const dt = Math.max((now - prevHandTime) / 1000, 1e-6);
    const speed = dist / dt; // px/s
    const measured = Math.min(8.0, speed * 0.0075);
    handWind = THREE.MathUtils.lerp(handWind, measured, 0.28);
  }
  prevHandCenter = metrics.center;
  prevHandTime = now;

  // 深度缩放：通过包围框宽度映射到 0.7 .. 1.9
  const screenW = metrics.boxW * window.innerWidth;
  const mapped = THREE.MathUtils.mapLinear(screenW, 80, 380, 0.7, 1.9);
  handDepthScale = THREE.MathUtils.lerp(handDepthScale, THREE.MathUtils.clamp(mapped, 0.6, 2.2), 0.1);

  // 手势判别 -> 切换形状（平滑吸附）
  const g = detectGesture(landmarks);
  if(g === 'open_palm') switchShape('sphere');
  else if(g === 'scissor_hand') switchShape('mok');
  else if(g === 'fist') switchShape('ring');
  else if(g === 'index_finger') switchShape('star');
  else if(g === 'thumbs_up') switchShape('heart');

  // 可选：你可以在这里显示当前手势到页面（console 或 DOM）
  // console.log('gesture', g);
}

/* 初始化 MediaPipe */
function initHands(){
  mpHands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
  mpHands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.55,
    minTrackingConfidence: 0.55
  });
  mpHands.onResults(onResults);

  mpCamera = new Camera(videoEl, {
    onFrame: async () => { await mpHands.send({image: videoEl}); },
    width: 1280,
    height: 720
  });
}

/* ---------- 物理：速度+加速度 + 平滑吸附逻辑 ---------- */
const SPRING = 0.008; // 吸附强度（可调整）
const MAX_A = 0.03;
const WIND_MULT = 0.01;
const DT_SCALE = 60.0; // 提升手感

function physicsStep(dt){
  // dt 秒
  const pos = geometry.getAttribute('position').array;
  // target array is "targets" defined earlier
  for(let i=0, i3=0; i<COUNT; i++, i3+=3){
    // target coordinates
    const tx = targets[i3], ty = targets[i3+1], tz = targets[i3+2];
    // current pos
    let px = pos[i3], py = pos[i3+1], pz = pos[i3+2];

    // spring acceleration toward target (scaled by current hand depthScale)
    let ax = (tx * handDepthScale - px) * SPRING;
    let ay = (ty * handDepthScale - py) * SPRING;
    let az = (tz * handDepthScale - pz) * SPRING;

    // wind: a randomized jitter proportional to handWind (short lived)
    if(handWind > 0.6){
      ax += (Math.random() - 0.5) * handWind * WIND_MULT;
      ay += (Math.random() - 0.5) * handWind * WIND_MULT;
      az += (Math.random() - 0.5) * handWind * WIND_MULT;
    }

    // clamp acceleration
    ax = THREE.MathUtils.clamp(ax, -MAX_A, MAX_A);
    ay = THREE.MathUtils.clamp(ay, -MAX_A, MAX_A);
    az = THREE.MathUtils.clamp(az, -MAX_A, MAX_A);

    // integrate velocity
    velocities[i3] += ax * dt;
    velocities[i3+1] += ay * dt;
    velocities[i3+2] += az * dt;

    // viscous damping for fluid feel
    velocities[i3] *= 0.93;
    velocities[i3+1] *= 0.93;
    velocities[i3+2] *= 0.93;

    // integrate position (scale to feel snappier)
    pos[i3] += velocities[i3] * dt * DT_SCALE;
    pos[i3+1] += velocities[i3+1] * dt * DT_SCALE;
    pos[i3+2] += velocities[i3+2] * dt * DT_SCALE;

    // small cohesion: keep particles from drifting too far by a weak centripetal term
    const cohesion = 0.0005;
    pos[i3] -= pos[i3] * cohesion * dt * DT_SCALE;
    pos[i3+1] -= pos[i3+1] * cohesion * dt * DT_SCALE;
    pos[i3+2] -= pos[i3+2] * cohesion * dt * DT_SCALE;
  }

  geometry.getAttribute('position').needsUpdate = true;

  // slowly decay handWind
  handWind *= 0.985;
}

/* ---------- 渲染循环 ---------- */
function animate(){
  requestAnimationFrame(animate);
  const now = performance.now();
  const dt = Math.min(0.05, (now - (animate._lastTime||now)) / 1000);
  animate._lastTime = now;

  physicsStep(dt);

  // subtle material breathing for life
  material.size = 4 + Math.sin(now * 0.0012) * 1.2;
  material.opacity = 0.85 + Math.sin(now * 0.0009) * 0.08;

  // scale group by handDepthScale for push/pull
  points.scale.setScalar(handDepthScale);

  renderer.render(scene, camera);
}

/* ---------- 启动流程（按钮） ---------- */
startButton.addEventListener('click', async () => {
  startButton.style.display = 'none';
  // 请求摄像头（后退兼容）
  try{
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio:false });
    videoEl.srcObject = stream;
    await videoEl.play();
  }catch(e){
    alert('无法访问摄像头：' + e.message);
    startButton.style.display = '';
    return;
  }

  // 初始化 hands & camera
  initHands();
  mpCamera.start();

  // 初始形状（球）
  makeSphere();
  // 开始渲染循环
  animate();
});

/* ---------- 页面可见性处理（节能） ---------- */
document.addEventListener('visibilitychange', () => {
  if(document.hidden){
    // pause camera updates if desired
    if(mpCamera) mpCamera.stop && mpCamera.stop();
  } else {
    if(mpCamera) mpCamera.start && mpCamera.start();
  }
});

/* ---------- 载入完成提示 ---------- */
console.log('AR particle morph ready. 点击启动 AR。');

/* ---------- 第二部分结束 ---------- */